[
  {
    "objectID": "posts/adventofcodeseries/day_one/index.html",
    "href": "posts/adventofcodeseries/day_one/index.html",
    "title": "Advent of Code Day 1",
    "section": "",
    "text": "I’m not a developer, so I don’t remember hearing about the Advent of Code before. Normally, I have a hard time getting excited about doing excericses unless it relates to one of the projects I’m working on. Advent is different. The idea of challenges and puzzles landed with me. It’s a way to think about problems and sharpen my skill set and talk about R. So without futher ado, here’s my solution for Day 1.\nThis year, the story behind AOC is helping christmas elves and collecting christmas stars. Day one had two questions: Each elf has a lot of calories as they doing their annual trek. Determine which elf has the most calories, then find the second and third highest tallies.\n\n\n\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(here)\nlibrary(glue)\n\n#didn't work\nurl <- \"https://adventofcode.com/2022/day/1/input\"\n#input <- read_html(url)\n\nMy libraries here are pretty standard. I’m a pretty dedicated Tidyverse user. I find the code easier to read and follow. That said, I do like to stay sharp with base R functions. Ito use Here because I just refuse set a working directory. And lastly, I was hoping I’d get to practice interacting with websites either via scrapping or downloading.\nThat didn’t happen. I’m must be missing something with rVest in that I would consistently get errors when trying to acquire that elven data. Given that it was already pretty late when that started, I just manually added the input to my script. For this blog post though, I wrote a tryCatch to show what I was getting\n\ntryCatch({\n  read_html(url)},\n  warning = function(warning_message){\n    message(\"Warning: {warning_message}\")\n    \n  },\n  error = function(error_message){\n    message(glue(\"My error has been: {error_message}\"))\n    \n  },\n  finally={\n    message()\n})\n\nMy error has been: Error in open.connection(x, \"rb\"): HTTP error 400.\n\n\n\n\n\nClearly, this has a lot to do with me not understanding enough of the HTTP protocol. No worry, that’s just future blog fodder.\nTurning to the input at hand, the instructions made it clear that each “empty line” indicated a new elf. My thought was to subset the string into a list, and then use lapply or map to get get the answers. That took longer than expected.\nI kep trying to subset the list based on regex or an NA. Regex is the bane of my existence, and doing it by NA just didn’t seem plausible. I realized early on that I needed to use a loop – a factor that I try to avoid with R. I was able to get the\nHere’s my final code:\n\ninput <- read_lines(\"inputs/input.txt\")\nelven_calories <- list()\nx <- c()\nfor(i in 1:length(input)){\n  if(str_detect(input[i], \"\\\\d+\")){\n   x <- c(x, input[i])\n  } else {\n    x <- as.integer(x)\n    elven_calories <- append(elven_calories, list(x))\n    x <- c()\n  }\n}\n\nBefore that version, even though the loop was working, nothing was being assigned to the elven_calories. The reason why? I didn’t assign it. It took an embarrassingly long time to realize that issue. Then I had another issue: The append function was adding vectors to the list, and not creating a new list. Once that was fixed, the it was just a matter of adding and sorting!\nHere’s the answer:\n\nelven_calories |> \n  map(sum) |>\n  unlist() |>\n  max()\n\n[1] 69528\n\nsums <- elven_calories |> \n  map(sum) |>\n  unlist() \n  \nsort(sums, decreasing = TRUE)[1:3] |> sum()\n\n[1] 206152"
  },
  {
    "objectID": "posts/adventofcodeseries/day_two/index.html",
    "href": "posts/adventofcodeseries/day_two/index.html",
    "title": "Advent of Code: Day Two",
    "section": "",
    "text": "I started this challenge in the late afternoon, but I did take a quick glance after I finished day one. The story of this challenge is a Rock, Paper, Scissors tournament and we have the inside scope of how the elves are going to shoot. It reminded me of the “Pop, Fizz, Buzz” case_when example. I still haven’t had time to investigate a way to pull the input, but the challenge days have just begun."
  },
  {
    "objectID": "posts/adventofcodeseries/day_two/index.html#rock-paper-scissors",
    "href": "posts/adventofcodeseries/day_two/index.html#rock-paper-scissors",
    "title": "Advent of Code: Day Two",
    "section": "Rock, Paper, Scissors",
    "text": "Rock, Paper, Scissors\nThe first thing I did was look at the input in a pretty standard way: Read the file and then call glimpse.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(here)\n\nhere() starts at /Users/marty/Dropbox (Personal)/CodingProjects/R/adventures_in_data_science\n\nlibrary(gt)\n\nday_two <- read_lines_raw(\"inputs/day2.txt\")\nclass(day_two[[1]])\n\n[1] \"raw\"\n\n\nOn the website, it’s a vector of pairs. I remember enough python to think that this maybe be a tuple to data frame situation. I’m still in the process of shaking off the rust, so I’m not sure finring up reticulate is the best option here. So instead, I look to find a good R solution. At first, I tried a little regex, but I quickly realized that the way read_lines imported the data would create a giant vector. So I tried something else. The documentation of read_lines has another function of read_lines_raw which “produces a list of raw vectors.”\nRaw isn’t a data type I’m familiar with, but a quick look at the literature pointed out the base R function rawToChar which solved the issue and gave me the list i needed.\nI’m sure that there are R folks who, armed with that list, could easily find the solution. I’m a sucker for tables, so the first thing I had to do was turn the list into a tibble. This was also an opportunity to work with more regex – a skill I sorely need.\n\nday_two <- day_two |> \n  map(rawToChar) |>\n  unlist() |>\n  as_tibble()\n  \ncolnames(day_two) <- \"hands\"\n\nday_two <- day_two |>\n  mutate(elf_hand = str_extract(hands, \"([^\\\\s]+)\"),\n         opposing_hand = str_extract(hands, \"(?<=\\\\s).*\")) |>\n  select(-hands)\n\nI thought the trick were the patterns \"([^\\\\s]+)\" and \"(\\\\s.+)\". Only the first pattern worked. The second pattern left the white space. A less elegant solution str_trim could fix it, but I wanted to figure out regex. It took a little digging on RegexTester, but I found a working pattern: \"(?\\<=\\\\s).\\*\"\nHere’s the first five entries of the new tibble:\n\nday_two |>\n  head(5) |>\n  gt() |>\n  tab_header(title = \"Rock, Paper, Scissors Guide\",\n             subtitle = md(\"*How I Beat the Elves at Their Own Game*\")) |>\n  cols_label(elf_hand = \"Elf Hand\", \n             opposing_hand = \"Opposing Hand\") |>\n  tab_style(\n    cell_fill(color = \"#87CEEB\"),\n    locations = cells_body(\n      rows = seq(1, 5, by = 2)\n  ))\n\n\n\n\n\n  \n    \n      Rock, Paper, Scissors Guide\n    \n    \n      How I Beat the Elves at Their Own Game\n    \n  \n  \n    \n      Elf Hand\n      Opposing Hand\n    \n  \n  \n    A\nZ\n    A\nZ\n    C\nY\n    A\nX\n    A\nX\n  \n  \n  \n\n\n\n\nWith this table then, I can answer the next part of the puzzle: Scoring.\nEach shape gives a base score: 1 for Rock, 2 for Paper, and 3 for Scissors. A loss, tie, or a win also awards points: 0, 3, and 6 respectively. I need to find my final score. To make these calculations, I’ll add two columns: Result and Score. I’ll calculate results with a function and do something similar with the score.\n\n#A = Rock\n#B = Paper\n#C = Scissors\n\n#X  = Rock 1\n#Y = Paper 2\n#Z = Scissors 3\n\nresult = function(h1, h2, ...){\n  case_when(\n    h1 == \"A\" & h2 == \"X\" ~\"Tie\",\n    h1 == \"A\" & h2 == \"Y\" ~\"Win\",\n    h1 == \"A\" & h2 == \"Z\" ~\"Loss\",\n    \n    h1 == \"B\" & h2 == \"X\" ~\"Loss\",\n    h1 == \"B\" & h2 == \"Y\" ~\"Tie\",\n    h1 == \"B\" & h2 == \"Z\" ~\"Win\",\n    \n    h1 == \"C\" & h2 == \"X\" ~\"Win\",\n    h1 == \"C\" & h2 == \"Y\" ~\"Loss\",\n    h1 == \"C\" & h2 == \"Z\" ~\"Tie\",\n  )\n}\n\nscore_hand = function(hand, ...){\n  case_when(\n    hand == \"X\" ~1,\n    hand == \"Y\" ~2,\n    hand == \"Z\" ~3\n    )\n}\n\nscore_result = function(result, ...){\n  case_when(\n    result == \"Win\" ~6,\n    result == \"Loss\" ~0,\n    result == \"Tie\" ~3\n  )\n}\n\nsum(score_hand(\"X\"), score_result(\"Tie\"))\n\n[1] 4\n\nday_two_part1 <- day_two |>\n  mutate(Result = result(elf_hand, opposing_hand)) |>\n  mutate(hand_score = score_hand(opposing_hand)) |>\n  mutate(result_score = score_result(Result)) |>\n  rowwise() |>\n  mutate(Score = sum(hand_score, result_score)) |>\n  select(1:3, Score)\n\nfinal_score <- sum(day_two_part1$Score)\n\nThe answer”: 1.2855^{4}. I got it quickly due to an error with the mutate call. What I wanted to do was a column wise operation to add the scores and just have a nice neat column. I ended up using mutate to create two temporary columns then using rowwise to make the sums.\n\nday_two_part1 |>\n  head(10) |>\n  gt() |>\n  tab_header(title = \"Rock, Paper, Scissors Guide: Scoring Results\",\n             subtitle = md(\"*How I Beat the Elves at Their Own Game*\")) |>\n  cols_label(elf_hand = \"Elf Hand\", \n             opposing_hand = \"Opposing Hand\") |>\n  tab_style(\n    cell_fill(color = \"#87CEEB\"),\n    locations = cells_body(\n      rows = seq(1, 10, by = 2)\n  ))\n\n\n\n\n\n  \n    \n      Rock, Paper, Scissors Guide: Scoring Results\n    \n    \n      How I Beat the Elves at Their Own Game\n    \n  \n  \n    \n      Elf Hand\n      Opposing Hand\n      Result\n      Score\n    \n  \n  \n    A\nZ\nLoss\n3\n    A\nZ\nLoss\n3\n    C\nY\nLoss\n2\n    A\nX\nTie\n4\n    A\nX\nTie\n4\n    A\nZ\nLoss\n3\n    C\nX\nWin\n7\n    A\nX\nTie\n4\n    C\nY\nLoss\n2\n    A\nZ\nLoss\n3\n  \n  \n  \n\n\n\n\nThe second part of the second challenge is a pretty great twist: The second column indicates the result of your play. “X means you need to lose, Y means you need to end the round in a draw, and Z means you need to win.”\nThe first thing I need to do here is rename opposing_hand to result. Which would be confusing if I didn’t change Resultto my_hand. I figured if I kept a similar table structure, I could reuse the scoring functions from part one. As I was doing this, I realized that I probably could have created more robust functions. Instead of dwelling on the idea of refactoring, I decided that I should finish and go back to the challenge if I had to.\n\n#z = win \n#y = tie\n#x = loss\n#A = Rock 1\n#B = Paper 2 \n#C = Scissors 3\n\noutcome <- function(result, ...){\n  case_when(\n    result == \"Z\" ~\"Win\",\n    result == \"Y\" ~\"Tie\",\n    result == \"X\" ~\"Loss\"\n  )\n}\n\nactual_play <- function(elf_hand, result, ...){\n  case_when(\n    elf_hand == \"A\" & result == \"Win\" ~\"Paper\",\n    elf_hand == \"A\" & result == \"Tie\" ~\"Rock\",\n    elf_hand == \"A\" & result == \"Loss\" ~\"Scissors\",\n    \n    elf_hand == \"B\" & result == \"Win\" ~\"Scissors\",\n    elf_hand == \"B\" & result == \"Tie\" ~\"Paper\",\n    elf_hand == \"B\" & result == \"Loss\" ~\"Rock\",\n    \n    elf_hand == \"C\" & result == \"Win\" ~\"Rock\",\n    elf_hand == \"C\" & result == \"Tie\" ~\"Scissors\",\n    elf_hand == \"C\" & result == \"Loss\" ~\"Paper\"\n  )\n}\n\nscore_hand_part2 = function(hand, ...){\n  case_when(\n    hand == \"Rock\" ~1,\n    hand == \"Paper\" ~2,\n    hand == \"Scissors\" ~3\n    )\n}\n\nday_two_part2 <- day_two_part1|>\n  rename(result = opposing_hand) |>\n  rename(my_hand = Result) |>\n  mutate(result = outcome(result)) |>\n  mutate(my_hand = actual_play(elf_hand, result))|>\n  mutate(hand_score = score_hand_part2(my_hand)) |>\n  mutate(result_score = score_result(result)) |>\n  rowwise() |>\n  mutate(Score = sum(hand_score, result_score)) |>\n  select(1, 3, 2, Score)\n\nnew_final_score <- sum(day_two_part2$Score)"
  },
  {
    "objectID": "posts/adventofcodeseries/day_four/index.html",
    "href": "posts/adventofcodeseries/day_four/index.html",
    "title": "Advent of Code: Day Four",
    "section": "",
    "text": "After a few hectic holiday months, I finally got back to the Advent of Code challenge. While I’m pretty confident when it comes to basic data analysis and cleaning, this kind of challenge is making me stretch my skills in an exciting way.\nThis challenge involved finding which pairs of elves have a range of areas that is completely subsumed by the other. So if Elf A has 2 - 6 and Elf B has 3 - 5, elf B is completely contained in Elf A’s range.\nFirst step, as usual, is loading the data and cleaning it. Immediately I started thinking of how to use a list to figure out the answer. This has everythign to do with using map to solve the previous questions AND from the Advanced R book. I couldn’t wrap my head around comparing vectors in a list. After trying, and failing, to grok it, I went to the tibble. I figured it’d be easier to spot check on a table than in a list, and also, mutate and regex make easy work of extracting digits.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(here)\n\nhere() starts at /Users/marty/Dropbox (Personal)/CodingProjects/R/adventures_in_data_science\n\npairs <- readr::read_lines(file.path(\"inputs\", \"day_four.txt\"))  %>% \n  str_split(\" \") %>%\n  str_c() %>%\n  as_tibble() %>%\n  set_names(\"elf_a\") %>%\n  mutate(elf_b = str_extract(elf_a, \"(?<=,).*\"),\n         elf_a = str_extract(elf_a, \"([^,]+)\"),\n         elf_a_start = str_extract(elf_a, \"([^-]+)\") %>%\n           as.integer(),\n         elf_a_end = str_extract(elf_a, \"(?<=-).*\") %>%\n           as.integer(),\n         elf_b_start = str_extract(elf_b, \"([^-]+)\") %>%\n           as.integer(), \n         elf_b_end = str_extract(elf_b, \"(?<=-).*\") %>%\n           as.integer(),\n         a_contains_b = elf_a_start <= elf_b_start & elf_a_end >= elf_b_end,\n         b_contains_a = elf_b_start <= elf_a_start & elf_b_end >= elf_a_end)\n\nThe code made a neat table.\n\nlibrary(tidyverse)\nlibrary(reactable) \n\npairs %>%\n  reactable(\n    defaultPageSize = 25,\n    pageSizeOptions = 100,\n    striped = TRUE,\n    bordered = TRUE,\n    theme = reactableTheme(\n      borderColor = \"#414141\",\n      stripedColor = \"#ADD8E6\"\n    )\n  )\n\n\n\n\n\n\nIf only the elves wanted tables. But no, I need numbers. Which is easy to get with a few more dplyr functions.\n\nanswer_1 <- pairs %>%\n  select(a_contains_b, b_contains_a) %>%\n  summarise(total = sum(a_contains_b) + sum(b_contains_a))\n\n\nanswer_2 <- pairs %>%\n    select(a_contains_b, b_contains_a) %>%\n    summarise(total_a = sum(a_contains_b) ,\n            total_b = sum(b_contains_a))\n\nThe answer I had was 567. It wasn’t right for this data set – but it was the right answer for someone. It made me think that maybe I wasn’t supposed to add up the columns – so I just did a quick summary table.\n\nanswer_2\n\n# A tibble: 1 × 2\n  total_a total_b\n    <int>   <int>\n1     282     285\n\n\nNeither answer worked. I did a quick search on google for a hint – and landed on Emil Hvitfeld’s solutions. Reviewing his work and mine… it was eye opening how he used R to solve the issues. He was solving questions with less code and in a vectorized approach. This is the kind of review I need to become a better R user. So I’m implemented his solution\n\nlibrary(tidyverse)\n\ninput <- readr::read_lines(file.path(\"inputs\", \"day_four.txt\")) %>%\n  strsplit(\"[-,]\") %>%\n  map(as.integer)\n\ncontain <- function(x) {\n  seq1 <- seq(x[1], x[2])\n  seq2 <- seq(x[3], x[4])\n\n  length(setdiff(seq1, seq2)) == 0 ||\n  length(setdiff(seq2, seq1)) == 0\n}\n\nsolution <- map_lgl(input, contain) %>%\n  sum()\n\nThis returned 532. That’s a difference of 35 over-laps. I had to see where my error was, so I ran the map function.\n\nmap_lgl(input, contain)\n\n   [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n  [13]  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE\n  [25]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE\n  [37]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n  [49] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n  [61] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n  [73]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n  [85]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n  [97]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n [109]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n [121] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [133] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE\n [145] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n [157] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n [169]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE\n [181]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n [193]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n [205] FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n [217]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE\n [229] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n [241]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n [253] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n [265] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n [277]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE\n [289]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n [301]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n [313]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [325]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [337]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n [349] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n [361] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n [373] FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [385] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n [397]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n [409] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n [421]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n [433]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n [445]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n [457]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [469]  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n [481] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n [493] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n [505]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [517] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n [529] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n [541]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n [553]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n [565] FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n [577] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n [589] FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [601]  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n [613] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE\n [625] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n [637] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n [649]  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE\n [661]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n [673]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE\n [685] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [697] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [709] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n [721]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE\n [733]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE\n [745]  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n [757]  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [769]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\n [781] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [793] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n [805]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [817]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n [829]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n [841]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n [853] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE\n [865]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n [877]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n [889]  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE\n [901] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n [913]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [925] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n [937]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n [949]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n [961]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n [973]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE\n [985]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n [997] FALSE  TRUE FALSE  TRUE\n\n\nReviewing a vector of booleans by hand was not a great idea, but it did lead me to my first thought about my error. There were 35 instances where both instances were true. That could be an issue. So I added a few steps to my answer to see if that was indeed the case.\n\npairs %>%\n  select(a_contains_b, b_contains_a)\n\n# A tibble: 1,000 × 2\n   a_contains_b b_contains_a\n   <lgl>        <lgl>       \n 1 FALSE        TRUE        \n 2 TRUE         FALSE       \n 3 FALSE        FALSE       \n 4 FALSE        FALSE       \n 5 FALSE        FALSE       \n 6 FALSE        TRUE        \n 7 FALSE        FALSE       \n 8 FALSE        TRUE        \n 9 FALSE        TRUE        \n10 TRUE         FALSE       \n# … with 990 more rows"
  },
  {
    "objectID": "posts/adventofcodeseries/day_three/index.html",
    "href": "posts/adventofcodeseries/day_three/index.html",
    "title": "Advent of Code: Day Three",
    "section": "",
    "text": "This challenge I started way too late, so it took more than one read to figure out what the challenge actually was. I read it a handful of times, and my take away is that Elves need a better way to organize their rucksacks. My first thought was creating a function to score the letters. The function isn’t robust, but it does the job.\n\nlibrary(tidyverse)\nlibrary(here)\n\nday_three <- read_lines(\"inputs/day_three.txt\")\n\nscore_letter <- function(letter, ...){\n  score = c()\n  alpha = c(letters, LETTERS)\n  value = c(1:52)\n  letter_value <- bind_cols(Letter = alpha, Value = value)\n  \n  #first edit\n  for(i in 1:str_length(letter)){\n    l = str_split(letter, \"\") |> \n      unlist()\n    score = c(score, letter_value$Value[letter_value$Letter == l[i]])\n  }\n  return(score)\n}\n\nUpon testing, I realized that the function wasn’t robust enough to handle a vector of letters, so I sussed out how to process scoring a vector. This actually came to me just as I fell asleep.\nThe next issue was to create a function that would subset the string in the middle.\n\nsplit_middle_string <- function(string, ...){\n  n = str_length(string)/2\n  front = string |>\n    str_sub(1, n)\n  \n  back = string |>\n    str_sub(n+1, str_length(string))\n  \n  return(list(front, back))\n}\n\nThis particular function was done in two steps. I had to add the n + 1 in the second round of edits. It was the comparing function that I spent the most time with. And with this one, I wanted to practice with lists.\n\ncompare_strings <- function(list, ...){\n  match = c()\n  front = list[1] |>\n    unlist()\n  count = str_length(front)\n  \n  x = front |>\n    map(str_split, \"\") |>\n    unlist()\n  \n  for(i in 1:count){\n    match = c(match, list[2] |>\n                 map(str_extract_all, x[i]) |>\n                 unlist())\n  }\n  match <- unique(match) #<- read the instructions\n  return(match)\n}\n\nI wanted to use the map function, as I think that’ll go a long way to make the remaining challenges easier. With this step, I think using a list was an elegant solution. The problem is, when I ran the solution, I was way over. When I ran the demo strings for the challenge through the each function, it worked – with one exception. I found ALL the duplicates. The challenge required one. I commented the edit that saved the function and my hairline.\n\n\nI probably could have combined the numeric section but because of the loop, I figured it would be easier to get the solution with an extra line.\n\ntotal <- list()\nfor(i in 1:length(day_three)){\n  total = append(total, day_three[i] |>\n    split_middle_string() |>\n    compare_strings()) \n}\n\nnumeric <- total |> \n  str_flatten() |> \n  score_letter()\n\nsum(numeric)\n\n[1] 7967"
  },
  {
    "objectID": "posts/adventofcodeseries/day_three/index.html#part-two-these-fucking-elves",
    "href": "posts/adventofcodeseries/day_three/index.html#part-two-these-fucking-elves",
    "title": "Advent of Code: Day Three",
    "section": "Part Two: These fucking elves",
    "text": "Part Two: These fucking elves\nThis challenge begins with collecting the elves into groups of 3 and looking for one common element between all 3. This was, by far, the most difficult challenge so far. I first thought a sequence would do it, then split and then read_lines_chunk. With each step, I ran into the issue of repeating the same string over and over.\nI solved it by writing out how I would solve it manually, per Hadley Wickham’s advice.\n\ngroup1 <- list(day_three[1:3])\ngroup2 <- list(day_three[4:6])\n\nFrom there it became quite apparent how to solve the problem. Appending the list is pretty simple and something I’ve done multiple times in this challenge. The light bulb went off with the seq function and subsetting the vector. When I was crafting the function, a few errors were thrown when I added the sequence function to the [[ function, so I assigned variables to make it a bit cleaner.\nAll that said, when this worked, I did shout for joy.\n\nx <- seq(1, 300, 3)\ny  <- list()\n\ngroup <- list()\nfor(i in 1:100){\n  b = x[i]\n  e = x[i]+2\n  y = list(day_three[b:e])\n  group = append(group, y)\n}"
  },
  {
    "objectID": "posts/adventofcodeseries/day_three/index.html#what-to-find",
    "href": "posts/adventofcodeseries/day_three/index.html#what-to-find",
    "title": "Advent of Code: Day Three",
    "section": "What to find",
    "text": "What to find\nWith the grouping done, the challenge was then to find a common character in the 3 strings. To start this section, I started by cutting and pasting the previous compare_strings function and then seeing if it could find the same characters from the instructions. While it wasn’t able to search all three groups, it was clear that if the function was more robust, it should work.\n\ndemo <- c(\"vJrwpWtwJgWrhcsFMMfFFhFp\", \"jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\", \"PmmdzqPrVvPwwTWBwg\")\n\nfind_badge <- function(list, ...){ \n  match = c()\n  delisting = list[[1]] %>%\n  unlist()\n  elves = length(delisting) \n  counts = str_length(delisting)\n  \n  x = delisting[[1]] %>%\n  map(str_split, \"\") %>%\n  unlist()\n\nfor(i in 1:counts){ \n  match = c(match, list[2] %>%\n              map(str_extract_all, x[i]) %>%\n              unlist()) } \n\nmatch = unique(match) #\\<- read the instructions \n\nreturn(match) \n}\n\nfind_badge(demo)\n\n[1] \"r\" \"s\" \"F\" \"M\" \"f\"\n\n\nBut it didn’t. There’s a way in R to check for list elements and to prevent the Out Of Bounds error, but I thought to myself this is not the purpose of R. As a vectorized language, there has to be a better way instead of looping over items and ensuring that I stay within bounds.\nI looked for a solution and found one on Stack Overflow, using Reduce and intersect.\nPer the documentation, “Reduce uses a binary function to successively combine the elements of a given vector and a possibly given initial value.” Put differently, Reduce takes two variables uses the supplied function to combine the elements of a list. Map and apply apply the function across all the elements in a list and keep them, Reduce combines to, well, reduce.\nThe intersect function finds elements across the vectors. In short, the Reduce and intersect function says: find all the common elements across these lists.\n\nstr_break <- function(x, ...){\n  broke_string = x %>%\n    map(str_split, \"\") %>%\n    unlist()\n  return(broke_string)\n}\n\nfind_character <- function(list, ...){\n  collected_characters = c()\n  for(i in 1:length(list)){\n    cluster = list[[i]] %>%\n      map(str_break)\n    common_character = Reduce(intersect, cluster)\n    collected_characters = c(collected_characters, common_character)\n  }\n  return(collected_characters)\n}\n\ncommon_elements <- find_character(group)\n\nclass(common_elements)\n\n[1] \"character\"\n\nscore <- score_letter(common_elements)\n\nWarning in 1:str_length(letter): numerical expression has 100 elements: only\nthe first used\n\n\nL, Q, w, q, Z, T, J, l, G, w, j, m, l, n, g, q, n, H, c, n, H, V, w, b, F, W, m, v, W, Z, Z, J, q, s, m, g, v, q, f, v, R, r, H, s, B, z, S, M, C, c, t, p, q, m, d, r, b, D, V, H, p, C, H, T, Z, s, R, R, l, C, d, Q, Q, d, v, S, J, J, M, z, Q, v, s, p, W, p, P, m, P, B, F, m, T, d, Q, B, J, r, Z, V\nWhich leads to a score of 38."
  },
  {
    "objectID": "posts/last_rmd/index.html",
    "href": "posts/last_rmd/index.html",
    "title": "What we use",
    "section": "",
    "text": "The best way to move this project forward is to start by explaining the current state of the court’s data and its data analysis. While deep dives into how we document cases and court proceedings are not the most exciting aspect of the project, they are a necessary part of making any lasting change. I’m not sure I’ll be doing my colleagues, and the young people I serve, any favors if this project does not address what does, and does not work, with our current system. By sharing how the court currently captures, stores, and transforms data, I will have an easier time communicating some of the decisions that I make regarding this project.\n\n\n\nWindows 95 Start Gif. Because this is where it all starts.\n\n\nJEMS was designed and coded by Anderson Consulting (then Accenture) in the late 1990s and deployed in early 2000s. The front end was created with Lansa The back-end is currently on MS SQL Server. This database stores all of our client data: Names, contact information, contacts, family members, charges, case notes, interventions, successes, and violations of probation. From what I’ve seen, the back-end is a solid relational database, centered around a young person’s ID number.\nThe State’s Attorney office creates the JEMS ID in a separate system (CRIMES). In the early days of JEMS, there was an issue of duplicate IDs for the young people, however, this error has been (mostly) corrected. Once a young person’s data transfers from CRIMES into JEMS, it becomes the responsibility of the probation department to maintain that data. The interface-green screen, text driven-does have a steep learning curve, but for data entry, the system works.\n\n\n\nJust a reminder about what the system currently looks like.\n\n\nOut of the box, JEMS does not produce many reports. Users can pull up what has been entered by nearly any other user, supervising POs can get an overview of their officers’ contacts and case notes, and some managers can print out reports on the success rates of programs and interventions. Given the structure of the back-end, if someone can explain the query to the JEMS caretakers, all sorts of reports can be generated. JEMS does export to MS Excel natively, so our data/research division uses that functionality to generate reports on length of detention stays and rates of violations of probation. Those reports are then used for a handful of tasks, including program evaluation and case-load equity1; however, management has significant discretion in determining appropriate case load levels. In short, JEMS fits basic needs of our department’s data entry, but its reporting features do leave a lot to be desired.\nIt is exceptionally easy to dismiss and mock JEMS-I do it on a daily basis. It is antiquated, counter-intuitive, and of questionable utility to the average field officer. It is also, however, a huge shift for the way Cook County Probation operates: A digital, centralized location that stores all of the contact information (Address, phone number, etc) and all of the interventions (home visits, school visits, programs, referrals, etc) of the young people we work with. Put differently, since its deployment in the 2000s, the court has collected data on at least 41,000 young people2. Data that would have otherwise been stored in paper family folders. That is a data set that is perfect for my project. In short, JEMS has a significant amount of data that has the potential to show the court not just what works, but why it works. That alone would be worth the price, and the hassle, of JEMS.\nIt is far from perfect, but JEMS has data that has real utility: Tens of thousands of young people, hundreds of thousands of interventions, and hundreds of programs and innovations are all documented in JEMS, in a format that is easily accessible. With this data, the court can be better informed on what has, and has not, worked across Cook County for nearly two decades. In short, the data in JEMS is screaming for a modern data analysis. That is exactly what I plan on doing.\n\n\n\n\nFootnotes\n\n\nCase load equity means ensuring that officers have a relatively equal amount of work.↩︎\nBased on the following calculation: 3,000 youth per year for 17 years, minus 10,000 for a conservative estimate, gives us 41000.↩︎"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/relaunch/index.html",
    "href": "posts/relaunch/index.html",
    "title": "Relaunch!",
    "section": "",
    "text": "this was 1\n\n\nthis was 2\n\n\nthis is 3"
  },
  {
    "objectID": "posts/test-post/index.html",
    "href": "posts/test-post/index.html",
    "title": "shut a your mouth",
    "section": "",
    "text": "1 + 1\n\n[1] 2\n\n\n\n\n\ntest 1\n\n\ntest 2:"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Adventures in Data Science",
    "section": "",
    "text": "Relaunch!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshut a your mouth\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdvent of Code: Day Four\n\n\n\ncode\n\n\nadvent of code\n\n\npuzzle\n\n\nlearning\n\n\n\n\n\n\n\nMarty\n\n\nFeb 20, 2023\n\n\n\n\n\n\n\n\n\n\n \n\n\n\nAdvent of Code: Day Two\n\n\n\ncode\n\n\nadvent of code\n\n\npuzzle\n\n\nlearning\n\n\n\n\n\n\n\nMarty\n\n\nDec 3, 2022\n\n\n\n\n\n\n\n\n\n\n \n\n\n\nAdvent of Code: Day Three\n\n\n\ncode\n\n\nadvent of code\n\n\npuzzle\n\n\nlearning\n\n\n\n\n\n\n\nMarty\n\n\nDec 3, 2022\n\n\n\n\n\n\n\n\n\n\n \n\n\n\nAdvent of Code Day 1\n\n\n\ncode\n\n\nadvent of code\n\n\npuzzle\n\n\nlearning\n\n\n\n\n\n\n\nMarty\n\n\nDec 2, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat we use\n\n\n\ncourt\n\n\n\n\n\n\n\nMarty\n\n\nNov 20, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nTristan O’Malley\n\n\nNov 20, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "I live, work, and organize in Chicago. I started learning data science in order to improve the data quality of my day job, and my interests have have since exploded to include spatial analysis, automation, data visualization, data story telling, and Bayesian statistics.\nData should be used for the betterment of everyone."
  }
]